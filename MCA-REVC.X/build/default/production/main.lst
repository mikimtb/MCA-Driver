CCS PCH C Compiler, Version 5.045, 5967               21-Nov-15 22:20

               Filename:   F:\Dropbox (Personal)\Doktorat\GitRepository\MCA Driver\MCA-REVC.X\build\default\production\main.lst

               ROM used:   664 bytes (4%)
                           Largest free fragment is 15716
               RAM used:   96 (12%) at main() level
                           105 (14%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   01FC
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   00BA
0060:  BTFSS  F9D.4
0062:  GOTO   006C
0066:  BTFSC  F9E.4
0068:  GOTO   010A
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... /*  
....................  * File:   main.c 
....................  * Author: Miroslav 
....................  * 
....................  * Created on November 19, 2015, 11:22 PM 
....................  */ 
....................  
.................... #include "main.h" 
.................... /*  
....................  * File:   main.h 
....................  * Author: Miroslav 
....................  * 
....................  * Created on November 19, 2015, 11:22 PM 
....................  */ 
....................  
.................... #ifndef main_H 
.................... #define main_H 
....................  
.................... #include <18F4431.h> 
.................... //////////// Standard Header file for the PIC18F4431 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4431 
*
0136:  DATA 0D,0A
0138:  DATA 52,75
013A:  DATA 6E,6E
013C:  DATA 69,6E
013E:  DATA 67,2E
0140:  DATA 2E,2E
0142:  DATA 0D,0A
0144:  DATA 00,00
*
01B8:  TBLRD*+
01BA:  MOVF   FF5,F
01BC:  BZ    01D6
01BE:  MOVFF  FF6,5F
01C2:  MOVFF  FF7,60
01C6:  MOVFF  FF5,61
01CA:  RCALL  0182
01CC:  MOVFF  5F,FF6
01D0:  MOVFF  60,FF7
01D4:  BRA    01B8
01D6:  GOTO   0284 (RETURN)
....................  
.................... #list 
....................  
....................  
.................... #device     ADC = 10  
.................... #fuses      H4 
.................... #fuses      NOFCMEN 
.................... #fuses      NOIESO 
.................... #fuses      NOPUT 
.................... #fuses      NOBROWNOUT 
.................... #fuses      NOWDT 
.................... #fuses      NOWINEN 
.................... #fuses      NOPWMPIN 
.................... #fuses      HPOL_HIGH 
.................... #fuses      LPOL_HIGH 
.................... #fuses      T1LOWPOWER 
.................... #fuses      FLTAD4 
.................... #fuses      SSP_RC 
.................... #fuses      NOPWMPIN 
.................... #fuses      MCLR 
.................... #fuses      NOLVP 
.................... #fuses      NODEBUG 
....................  
.................... #define     RX_PIN      PIN_C7 
.................... #define     TX_PIN      PIN_C6 
.................... #define     RS485_RW    PIN_C0 
....................  
.................... #use delay(clock = 40MHZ) 
.................... #use rs232(xmit=TX_PIN, rcv=RX_PIN, enable=RS485_RW) 
*
00EC:  BCF    F94.0
00EE:  BSF    F8B.0
00F0:  BTFSS  F9E.4
00F2:  BRA    00F0
00F4:  BCF    F94.0
00F6:  BSF    F8B.0
00F8:  MOVFF  67,FAD
00FC:  NOP   
00FE:  BTFSS  FAC.1
0100:  BRA    00FE
0102:  BCF    F94.0
0104:  BCF    F8B.0
0106:  GOTO   0124 (RETURN)
....................   
.................... // UART Registers and bits 
.................... #byte TXSTA=0xFAC 
.................... #bit  BRGH=TXSTA.2 
.................... #bit  SYNC=TXSTA.4 
....................  
.................... #byte RCSTA=0xFAB 
.................... #bit  ADDEN=RCSTA.3 
.................... #bit  RX9=RCSTA.6 
....................  
.................... #byte BAUDCTL=0xFAA 
.................... #bit  BRG16=BAUDCTL.3 
....................  
.................... int16 SPBRG;  
.................... #locate SPBRG=0xFAF 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "uart.h" 
.................... /*  
....................  * File:   uart.h 
....................  * Author: Miroslav 
....................  * 
....................  * Created on November 20, 2015, 12:17 AM 
....................  */ 
....................  
.................... #ifndef UART_H 
.................... #define	UART_H 
....................  
.................... void serial_rcv_isr(void); 
.................... void serial_td_isr(void); 
.................... BYTE uart_bgetc(void); 
.................... void uart_bputc(BYTE); 
.................... void uart_init(unsigned int, BYTE); 
....................  
.................... #endif	/* UART_H */ 
....................  
....................  
.................... #include "uart.c" 
.................... /* 
....................  * File:   uart.c 
....................  * Author: Miroslav 
....................  * 
....................  * Created on November 19, 2015, 11:22 PM 
....................  */ 
....................  
.................... #include "uart.h" 
.................... /*  
....................  * File:   uart.h 
....................  * Author: Miroslav 
....................  * 
....................  * Created on November 20, 2015, 12:17 AM 
....................  */ 
....................  
.................... #ifndef UART_H 
.................... #define	UART_H 
....................  
.................... void serial_rcv_isr(void); 
.................... void serial_td_isr(void); 
.................... BYTE uart_bgetc(void); 
.................... void uart_bputc(BYTE); 
.................... void uart_init(unsigned int, BYTE); 
....................  
.................... #endif	/* UART_H */ 
....................  
....................  
....................  
.................... //Defines 
.................... #define BUFFER_SIZE   32 
.................... #define uart_bkbhit (in.next_in!=in.next_out) 
.................... //Variables 
.................... typedef struct buffer 
.................... { 
....................     BYTE uart_buffer[BUFFER_SIZE]; 
....................     BYTE next_in; 
....................     BYTE next_out; 
.................... } t_buffer; 
....................  
.................... t_buffer in = {{0}, 0, 0}; 
.................... t_buffer out = {{0}, 0, 0}; 
.................... // Functions 
.................... /** 
....................  * UART receive interrupt handler 
....................  */ 
.................... #int_rda 
.................... void serial_rcv_isr() 
.................... { 
....................     int t; 
....................      
....................     in.uart_buffer[in.next_in] = getc(); 
*
00BA:  CLRF   03
00BC:  MOVF   39,W
00BE:  ADDLW  19
00C0:  MOVWF  FE9
00C2:  MOVLW  00
00C4:  ADDWFC 03,W
00C6:  MOVWF  FEA
00C8:  BTFSS  F9E.5
00CA:  BRA    00C8
00CC:  MOVFF  FAE,FEF
....................     t = in.next_in; 
00D0:  MOVFF  39,66
....................     in.next_in = (in.next_in + 1) % BUFFER_SIZE; 
00D4:  MOVLW  01
00D6:  ADDWF  39,W
00D8:  ANDLW  1F
00DA:  MOVWF  39
....................     if (in.next_in == in.next_out) 
00DC:  MOVF   3A,W
00DE:  SUBWF  39,W
00E0:  BNZ   00E6
....................         in.next_in = t;                                // Buffer full 
00E2:  MOVFF  66,39
.................... } 
.................... /** 
....................  * UART transmit interrupt handler 
....................  */ 
00E6:  BCF    F9E.5
00E8:  GOTO   006C
.................... #int_tbe 
.................... void serial_td_isr() 
.................... { 
....................     if (out.next_in != out.next_out) 
*
010A:  MOVF   5C,W
010C:  SUBWF  5B,W
010E:  BZ    012E
....................     { 
....................         putc(out.uart_buffer[out.next_out]); 
0110:  CLRF   03
0112:  MOVF   5C,W
0114:  ADDLW  3B
0116:  MOVWF  FE9
0118:  MOVLW  00
011A:  ADDWFC 03,W
011C:  MOVWF  FEA
011E:  MOVFF  FEF,67
0122:  BRA    00EC
....................         out.next_out = (out.next_out + 1) % BUFFER_SIZE; 
0124:  MOVLW  01
0126:  ADDWF  5C,W
0128:  ANDLW  1F
012A:  MOVWF  5C
....................     } 
012C:  BRA    0130
....................     else 
....................         disable_interrupts(int_tbe); 
012E:  BCF    F9D.4
0130:  BCF    F9E.4
0132:  GOTO   006C
.................... } 
.................... /** 
....................  * uart_bgetc, Function return one byte from uart input buffer 
....................  * @return , first buffer that is written to the uart input buffer. 
....................  */ 
.................... BYTE uart_bgetc() 
.................... { 
....................     BYTE c; 
....................      
....................     //while(!uart_bkbhit);                          // This should be checked 
....................                                                     // in parser before state 
....................                                                     //machine is called 
....................     c = in.uart_buffer[in.next_out]; 
*
01DA:  CLRF   03
01DC:  MOVF   3A,W
01DE:  ADDLW  19
01E0:  MOVWF  FE9
01E2:  MOVLW  00
01E4:  ADDWFC 03,W
01E6:  MOVWF  FEA
01E8:  MOVFF  FEF,5F
....................     in.next_out = (in.next_out + 1) % BUFFER_SIZE; 
01EC:  MOVLW  01
01EE:  ADDWF  3A,W
01F0:  ANDLW  1F
01F2:  MOVWF  3A
....................     return (c); 
01F4:  MOVFF  5F,01
01F8:  GOTO   028C (RETURN)
.................... } 
.................... /** 
....................  * bputc, Function add one byte to uart output buffer 
....................  * @param c, byte that will be added in uart output buffer. 
....................  */ 
.................... void uart_bputc(BYTE c) 
.................... { 
....................     short restart; 
....................     int ni; 
....................      
....................     restart = out.next_in == out.next_out; 
*
0182:  BCF    x62.0
0184:  MOVF   5C,W
0186:  SUBWF  5B,W
0188:  BNZ   018C
018A:  BSF    x62.0
....................     out.uart_buffer[out.next_in] = c; 
018C:  CLRF   03
018E:  MOVF   5B,W
0190:  ADDLW  3B
0192:  MOVWF  FE9
0194:  MOVLW  00
0196:  ADDWFC 03,W
0198:  MOVWF  FEA
019A:  MOVFF  61,FEF
....................     ni = (out.next_in + 1) % BUFFER_SIZE; 
019E:  MOVLW  01
01A0:  ADDWF  5B,W
01A2:  ANDLW  1F
01A4:  MOVWF  x63
....................     while(ni == out.next_out); 
01A6:  MOVF   5C,W
01A8:  SUBWF  x63,W
01AA:  BZ    01A6
....................     out.next_in = ni; 
01AC:  MOVFF  63,5B
....................     if (restart) 
01B0:  BTFSS  x62.0
01B2:  BRA    01B6
....................         enable_interrupts(int_tbe); 
01B4:  BSF    F9D.4
01B6:  RETURN 0
.................... } 
.................... /** 
....................  * uart_init, Function configure uart peripheral 
....................  * @param baudrate, Possible baudrates are: 1 - 19200, 2 - 115200, 3 - 256000 
....................  * @param dev_id, Device address used in RS485 communication 
....................  */ 
.................... void uart_init(unsigned int baudrate, BYTE dev_id) 
.................... { 
....................     unsigned long divisor; 
....................      
....................     switch (baudrate) 
*
0146:  MOVF   5F,W
0148:  XORLW  01
014A:  BZ    0156
014C:  XORLW  03
014E:  BZ    0160
0150:  XORLW  01
0152:  BZ    0168
0154:  BRA    016E
....................     { 
....................         case 1: 
....................             //setup_uart(19200); 
....................             divisor = 520; 
0156:  MOVLW  02
0158:  MOVWF  x62
015A:  MOVLW  08
015C:  MOVWF  x61
....................             break; 
015E:  BRA    016E
....................         case 2: 
....................             //setup_uart(115200); 
....................             divisor = 85; 
0160:  CLRF   x62
0162:  MOVLW  55
0164:  MOVWF  x61
....................             break; 
0166:  BRA    016E
....................         case 3: 
....................             //setup_uart(256000); 
....................             divisor = 38; 
0168:  CLRF   x62
016A:  MOVLW  26
016C:  MOVWF  x61
....................             break; 
....................     } 
....................      
....................     // Switch to 16bit mode 
....................     SYNC = 0; 
016E:  BCF    FAC.4
....................     BRGH = 1; 
0170:  BSF    FAC.2
....................     BRG16 = 1; 
0172:  BSF    FAA.3
....................     // Select 9-bit reception 
....................     //RX9 = 0; 
....................     // Disable uart address detecion on receive 
....................     //ADDEN = 0; 
....................     // Configure uart speed 
....................     SPBRG = divisor; 
0174:  MOVFF  62,FB0
0178:  MOVFF  61,FAF
....................     //setup_uart(UART_ADDRESS); 
....................     enable_interrupts(INT_RDA); 
017C:  BSF    F9D.5
017E:  GOTO   0276 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void main() 
*
01FC:  CLRF   FF8
01FE:  BCF    FD0.7
0200:  BSF    07.7
0202:  BCF    F94.0
0204:  BCF    F8B.0
0206:  BSF    FAA.3
0208:  MOVLW  11
020A:  MOVWF  FAF
020C:  MOVLW  04
020E:  MOVWF  FB0
0210:  MOVLW  A6
0212:  MOVWF  FAC
0214:  MOVLW  90
0216:  MOVWF  FAB
0218:  CLRF   5E
021A:  CLRF   5D
021C:  BCF    FB9.0
021E:  BCF    FC1.6
0220:  BCF    FC1.7
0222:  MOVLW  00
0224:  MOVWF  FB8
0226:  BRA    022E
0228:  DATA 44,40
022A:  DATA 19,00
022C:  DATA 00,00
022E:  MOVLW  00
0230:  MOVWF  FF8
0232:  MOVLW  02
0234:  MOVWF  FF7
0236:  MOVLW  28
0238:  MOVWF  FF6
023A:  TBLRD*+
023C:  MOVF   FF5,W
023E:  MOVWF  00
0240:  XORLW  00
0242:  BZ    026A
0244:  TBLRD*+
0246:  MOVF   FF5,W
0248:  MOVWF  01
024A:  BTFSC  FE8.7
024C:  BRA    0258
024E:  ANDLW  0F
0250:  MOVWF  FEA
0252:  TBLRD*+
0254:  MOVFF  FF5,FE9
0258:  BTFSC  01.6
025A:  TBLRD*+
025C:  BTFSS  01.6
025E:  TBLRD*+
0260:  MOVFF  FF5,FEE
0264:  DCFSNZ 00,F
0266:  BRA    023A
0268:  BRA    025C
026A:  CLRF   FF8
.................... { 
....................     uart_init(2, 120);  
026C:  MOVLW  02
026E:  MOVWF  5F
0270:  MOVLW  78
0272:  MOVWF  x60
0274:  BRA    0146
....................     enable_interrupts(GLOBAL); 
0276:  MOVLW  C0
0278:  IORWF  FF2,F
....................      
....................     printf(uart_bputc, "\r\n\Running...\r\n"); 
027A:  MOVLW  36
027C:  MOVWF  FF6
027E:  MOVLW  01
0280:  MOVWF  FF7
0282:  BRA    01B8
....................      
....................     while (1) 
....................     { 
....................         //delay_ms(5000); 
....................         //printf("\r\nBuffered data => \r\n"); 
....................         while (uart_bkbhit) 
0284:  MOVF   3A,W
0286:  SUBWF  39,W
0288:  BZ    0298
....................             uart_bputc(uart_bgetc()); 
028A:  BRA    01DA
028C:  MOVFF  01,5F
0290:  MOVFF  01,61
0294:  RCALL  0182
0296:  BRA    0284
0298:  BRA    0284
....................     } 
.................... } 
....................  
029A:  SLEEP 

Configuration Fuses:
   Word  1: 0600   H4 NOFCMEN NOIESO
   Word  2: 3E0D   NOPUT NOBROWNOUT BORV20 NOWDT WDT32768 NOWINEN
   Word  3: 9C3C   NOPWMPIN LPOL_HIGH HPOL_HIGH T1LOWPOWER FLTAD4 SSP_RC PWM4B5 EXCLKC3 MCLR
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
