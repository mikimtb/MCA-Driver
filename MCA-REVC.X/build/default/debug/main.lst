CCS PCH C Compiler, Version 5.045, 5967               23-Nov-15 00:06

               Filename:   F:\Dropbox (Personal)\Doktorat\GitRepository\MCA Driver\MCA-REVC.X\build\default\debug\main.lst

               ROM used:   1216 bytes (8%)
                           Largest free fragment is 14332
               RAM used:   200 (26%) at main() level
                           214 (28%) worst case
               Stack used: 3 locations (0 in main + 3 for interrupts)
               Stack size: 30

*
0000:  GOTO   0412
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   0198
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   00C6
006C:  BTFSS  F9D.4
006E:  GOTO   0078
0072:  BTFSC  F9E.4
0074:  GOTO   0116
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVFF  15,FF5
00B2:  MOVFF  16,FF6
00B6:  MOVFF  17,FF7
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
.................... /*  
....................  * File:   main.c 
....................  * Author: Miroslav 
....................  * 
....................  * Created on November 19, 2015, 11:22 PM 
....................  */ 
....................  
.................... #include "main.h" 
.................... /*  
....................  * File:   main.h 
....................  * Author: Miroslav 
....................  * 
....................  * Created on November 19, 2015, 11:22 PM 
....................  */ 
....................  
.................... #ifndef main_H 
.................... #define main_H 
....................  
.................... #include <18F4431.h> 
.................... //////////// Standard Header file for the PIC18F4431 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4431 
*
0178:  TBLRD*+
017A:  MOVF   FF5,F
017C:  BZ    0196
017E:  MOVFF  FF6,CF
0182:  MOVFF  FF7,D0
0186:  MOVFF  FF5,D1
018A:  RCALL  0142
018C:  MOVFF  CF,FF6
0190:  MOVFF  D0,FF7
0194:  BRA    0178
0196:  RETURN 0
*
01B8:  DATA 54,69
01BA:  DATA 6D,65
01BC:  DATA 6F,75
01BE:  DATA 74,20
01C0:  DATA 6F,63
01C2:  DATA 63,75
01C4:  DATA 72,72
01C6:  DATA 65,64
01C8:  DATA 21,0D
01CA:  DATA 0A,00
01CC:  MOVFF  FEC,FFA
01D0:  MOVF   FED,F
01D2:  MOVFF  FEF,FE8
01D6:  MOVWF  FF9
01D8:  RETURN 0
01DA:  DATA 4D,65
01DC:  DATA 73,73
01DE:  DATA 61,67
01E0:  DATA 65,20
01E2:  DATA 72,65
01E4:  DATA 63,65
01E6:  DATA 69,76
01E8:  DATA 65,20
01EA:  DATA 64,6F
01EC:  DATA 6E,65
01EE:  DATA 2E,0D
01F0:  DATA 0A,00
01F2:  DATA 0D,0A
01F4:  DATA 52,75
01F6:  DATA 6E,6E
01F8:  DATA 69,6E
01FA:  DATA 67,2E
01FC:  DATA 2E,2E
01FE:  DATA 0D,0A
0200:  DATA 00,00
....................  
.................... #list 
....................  
....................  
.................... #device     ADC = 10  
.................... #fuses      H4 
.................... #fuses      NOFCMEN 
.................... #fuses      NOIESO 
.................... #fuses      NOPUT 
.................... #fuses      NOBROWNOUT 
.................... #fuses      NOWDT 
.................... #fuses      NOWINEN 
.................... #fuses      NOPWMPIN 
.................... #fuses      HPOL_HIGH 
.................... #fuses      LPOL_HIGH 
.................... #fuses      T1LOWPOWER 
.................... #fuses      FLTAD4 
.................... #fuses      SSP_RC 
.................... #fuses      NOPWMPIN 
.................... #fuses      MCLR 
.................... #fuses      NOLVP 
.................... #fuses      NODEBUG 
....................  
.................... #define     RX_PIN      PIN_C7 
.................... #define     TX_PIN      PIN_C6 
.................... #define     RS485_RW    PIN_C0 
....................  
.................... #use delay(clock = 40MHZ) 
.................... #use rs232(xmit=TX_PIN, rcv=RX_PIN, enable=RS485_RW) 
*
00F8:  BCF    F94.0
00FA:  BSF    F8B.0
00FC:  BTFSS  F9E.4
00FE:  BRA    00FC
0100:  BCF    F94.0
0102:  BSF    F8B.0
0104:  MOVFF  D0,FAD
0108:  NOP   
010A:  BTFSS  FAC.1
010C:  BRA    010A
010E:  BCF    F94.0
0110:  BCF    F8B.0
0112:  GOTO   0130 (RETURN)
....................   
.................... // UART Registers and bits 
.................... #byte TXSTA=0xFAC 
.................... #bit  BRGH=TXSTA.2 
.................... #bit  SYNC=TXSTA.4 
....................  
.................... #byte RCSTA=0xFAB 
.................... #bit  ADDEN=RCSTA.3 
.................... #bit  RX9=RCSTA.6 
....................  
.................... #byte BAUDCTL=0xFAA 
.................... #bit  BRG16=BAUDCTL.3 
....................  
.................... int16 SPBRG;  
.................... #locate SPBRG=0xFAF 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "uart.h" 
.................... /*  
....................  * File:   uart.h 
....................  * Author: Miroslav 
....................  * 
....................  * Created on November 20, 2015, 12:17 AM 
....................  */ 
....................  
.................... #ifndef UART_H 
.................... #define	UART_H 
....................  
.................... void serial_rcv_isr(void); 
.................... void serial_td_isr(void); 
.................... BYTE uart_bgetc(void); 
.................... void uart_bputc(BYTE); 
.................... void uart_init(unsigned int, BYTE); 
.................... /* Uart parser state machine states */ 
.................... void parse_uart_data(void);  
.................... void wait_for_start(void);  // Waits for the # character 
.................... void wait_for_adr(void);    // Wait for device address 
.................... void parse_id(void);        // Reads the 3 char identifier, stores it in data_id 
.................... void parse_length(void);    // Reads [LENGTH] field, stores it in data_length 
.................... void parse_data(void);      // Reads the data into data_buffer[] 
.................... void parse_crc(void);       // Reads the crc checksum (and checks the data) 
.................... void parse_end(void);       // End of data packet (#) handling.. start all over. 
.................... short crc_check(void);       
....................  
.................... #endif	/* UART_H */ 
....................  
....................  
.................... #include "uart.c" 
.................... /* 
....................  * File:   uart.c 
....................  * Author: Miroslav 
....................  * 
....................  * Created on November 19, 2015, 11:22 PM 
....................  */ 
....................  
.................... #include "uart.h" 
.................... /*  
....................  * File:   uart.h 
....................  * Author: Miroslav 
....................  * 
....................  * Created on November 20, 2015, 12:17 AM 
....................  */ 
....................  
.................... #ifndef UART_H 
.................... #define	UART_H 
....................  
.................... void serial_rcv_isr(void); 
.................... void serial_td_isr(void); 
.................... BYTE uart_bgetc(void); 
.................... void uart_bputc(BYTE); 
.................... void uart_init(unsigned int, BYTE); 
.................... /* Uart parser state machine states */ 
.................... void parse_uart_data(void);  
.................... void wait_for_start(void);  // Waits for the # character 
.................... void wait_for_adr(void);    // Wait for device address 
.................... void parse_id(void);        // Reads the 3 char identifier, stores it in data_id 
.................... void parse_length(void);    // Reads [LENGTH] field, stores it in data_length 
.................... void parse_data(void);      // Reads the data into data_buffer[] 
.................... void parse_crc(void);       // Reads the crc checksum (and checks the data) 
.................... void parse_end(void);       // End of data packet (#) handling.. start all over. 
.................... short crc_check(void);       
....................  
.................... #endif	/* UART_H */ 
....................  
....................  
....................  
.................... //Defines 
.................... #define UART_RX_TIMEOUT     1                   // Timeout in mS 
.................... #define TIMER1_REFRESH      (long)(65536 - (UART_RX_TIMEOUT * 10000)) 
.................... #define UART_BUFFER_SIZE    64 
.................... #define DATA_BUFFER_SIZE    32     
.................... #define uart_bkbhit (in.next_in!=in.next_out) 
....................  
.................... // Type definitions 
.................... typedef struct buffer 
.................... { 
....................     BYTE uart_buffer[UART_BUFFER_SIZE]; 
....................     BYTE next_in; 
....................     BYTE next_out; 
.................... } t_buffer; 
....................  
.................... typedef struct package 
.................... { 
....................     BYTE data_buffer[DATA_BUFFER_SIZE]; 
....................     BYTE dev_address; 
....................     BYTE ID; 
....................     BYTE data_length; 
....................     BYTE crc; 
.................... } t_package; 
....................  
.................... typedef void (*t_fptr)(void); 
.................... //Variables 
.................... //UART 
.................... t_buffer in = {{0}, 0, 0}; 
.................... t_buffer out = {{0}, 0, 0}; 
.................... //Message parser 
.................... t_package data = {{0}, 0, 0, 0}; 
....................  
.................... //Pointer to a function that takes no parameters and returns nothing. 
.................... t_fptr parse_next = wait_for_start;          // Initialize the pointer to point to first state 
.................... int count = 0;                               // Variable used in parse_data function 
.................... // Functions 
.................... /** 
....................  * UART receive interrupt handler 
....................  */ 
.................... #int_rda 
.................... void serial_rcv_isr() 
.................... { 
....................     int t; 
....................      
....................     in.uart_buffer[in.next_in] = getc(); 
*
00C6:  CLRF   03
00C8:  MOVF   5A,W
00CA:  ADDLW  1A
00CC:  MOVWF  FE9
00CE:  MOVLW  00
00D0:  ADDWFC 03,W
00D2:  MOVWF  FEA
00D4:  BTFSS  F9E.5
00D6:  BRA    00D4
00D8:  MOVFF  FAE,FEF
....................     t = in.next_in; 
00DC:  MOVFF  5A,CF
....................     in.next_in = (in.next_in + 1) % UART_BUFFER_SIZE; 
00E0:  MOVLW  01
00E2:  ADDWF  5A,W
00E4:  ANDLW  3F
00E6:  MOVWF  5A
....................     if (in.next_in == in.next_out) 
00E8:  MOVF   5B,W
00EA:  SUBWF  5A,W
00EC:  BNZ   00F2
....................         in.next_in = t;                                // Buffer full 
00EE:  MOVFF  CF,5A
.................... } 
.................... /** 
....................  * UART transmit interrupt handler 
....................  */ 
00F2:  BCF    F9E.5
00F4:  GOTO   0078
.................... #int_tbe 
.................... void serial_td_isr() 
.................... { 
....................     if (out.next_in != out.next_out) 
*
0116:  MOVF   x9D,W
0118:  SUBWF  x9C,W
011A:  BZ    013A
....................     { 
....................         putc(out.uart_buffer[out.next_out]); 
011C:  CLRF   03
011E:  MOVF   x9D,W
0120:  ADDLW  5C
0122:  MOVWF  FE9
0124:  MOVLW  00
0126:  ADDWFC 03,W
0128:  MOVWF  FEA
012A:  MOVFF  FEF,D0
012E:  BRA    00F8
....................         out.next_out = (out.next_out + 1) % UART_BUFFER_SIZE; 
0130:  MOVLW  01
0132:  ADDWF  x9D,W
0134:  ANDLW  3F
0136:  MOVWF  x9D
....................     } 
0138:  BRA    013C
....................     else 
....................         disable_interrupts(int_tbe); 
013A:  BCF    F9D.4
013C:  BCF    F9E.4
013E:  GOTO   0078
.................... } 
.................... /** 
....................  * TIMER1 overflow interrupt handler 
....................  */ 
.................... int timer1_isr_count = 0; 
.................... #int_timer1 
.................... void timer1_overflow_isr() 
.................... { 
....................     /*if(timer1_isr_count < 1) 
....................     { 
....................         timer1_isr_count++; 
....................         return; 
....................     }*/ 
....................     parse_next = wait_for_start; 
*
0198:  MOVLW  02
019A:  MOVWF  03
019C:  MOVLW  62
019E:  MOVWF  xC2
01A0:  MOVFF  03,C3
....................     disable_interrupts(int_timer1); 
01A4:  BCF    F9D.0
....................     timer1_isr_count = 0; 
01A6:  CLRF   xC5
....................      
....................     printf(uart_bputc, "Timeout occurred!\r\n");    // Debug, remove for final version 
01A8:  MOVLW  B8
01AA:  MOVWF  FF6
01AC:  MOVLW  01
01AE:  MOVWF  FF7
01B0:  RCALL  0178
01B2:  BCF    F9E.0
01B4:  GOTO   0078
.................... } 
.................... /** 
....................  * uart_bgetc, Function return one byte from uart input buffer 
....................  * @return , first buffer that is written to the uart input buffer. 
....................  */ 
.................... BYTE uart_bgetc() 
.................... { 
....................     BYTE c; 
....................      
....................     //while(!uart_bkbhit);                          // This should be checked 
....................                                                     // in parser before state 
....................                                                     //machine is called 
....................     c = in.uart_buffer[in.next_out]; 
*
0242:  CLRF   03
0244:  MOVF   5B,W
0246:  ADDLW  1A
0248:  MOVWF  FE9
024A:  MOVLW  00
024C:  ADDWFC 03,W
024E:  MOVWF  FEA
0250:  MOVFF  FEF,CA
....................     in.next_out = (in.next_out + 1) % UART_BUFFER_SIZE; 
0254:  MOVLW  01
0256:  ADDWF  5B,W
0258:  ANDLW  3F
025A:  MOVWF  5B
....................     return (c); 
025C:  MOVFF  CA,01
0260:  RETURN 0
.................... } 
.................... /** 
....................  * bputc, Function add one byte to uart output buffer 
....................  * @param c, byte that will be added in uart output buffer. 
....................  */ 
.................... void uart_bputc(BYTE c) 
.................... { 
....................     short restart; 
....................     int ni; 
....................      
....................     restart = out.next_in == out.next_out; 
*
0142:  BCF    xD2.0
0144:  MOVF   x9D,W
0146:  SUBWF  x9C,W
0148:  BNZ   014C
014A:  BSF    xD2.0
....................     out.uart_buffer[out.next_in] = c; 
014C:  CLRF   03
014E:  MOVF   x9C,W
0150:  ADDLW  5C
0152:  MOVWF  FE9
0154:  MOVLW  00
0156:  ADDWFC 03,W
0158:  MOVWF  FEA
015A:  MOVFF  D1,FEF
....................     ni = (out.next_in + 1) % UART_BUFFER_SIZE; 
015E:  MOVLW  01
0160:  ADDWF  x9C,W
0162:  ANDLW  3F
0164:  MOVWF  xD3
....................     while(ni == out.next_out); 
0166:  MOVF   x9D,W
0168:  SUBWF  xD3,W
016A:  BZ    0166
....................     out.next_in = ni; 
016C:  MOVFF  D3,9C
....................     if (restart) 
0170:  BTFSS  xD2.0
0172:  BRA    0176
....................         enable_interrupts(int_tbe); 
0174:  BSF    F9D.4
0176:  RETURN 0
.................... } 
.................... /** 
....................  * uart_init, Function configure uart peripheral 
....................  * @param baudrate, Possible baudrates are: 1 - 19200, 2 - 115200, 3 - 256000 
....................  * @param dev_id, Device address used in RS485 communication 
....................  */ 
.................... void uart_init(unsigned int baudrate, BYTE dev_id) 
.................... { 
....................     unsigned long divisor; 
....................      
....................     switch (baudrate) 
*
0202:  MOVF   xC8,W
0204:  XORLW  01
0206:  BZ    0212
0208:  XORLW  03
020A:  BZ    021C
020C:  XORLW  01
020E:  BZ    0224
0210:  BRA    022A
....................     { 
....................         case 1: 
....................             //setup_uart(19200); 
....................             divisor = 520; 
0212:  MOVLW  02
0214:  MOVWF  xCB
0216:  MOVLW  08
0218:  MOVWF  xCA
....................             break; 
021A:  BRA    022A
....................         case 2: 
....................             //setup_uart(115200); 
....................             divisor = 85; 
021C:  CLRF   xCB
021E:  MOVLW  55
0220:  MOVWF  xCA
....................             break; 
0222:  BRA    022A
....................         case 3: 
....................             //setup_uart(256000); 
....................             divisor = 38; 
0224:  CLRF   xCB
0226:  MOVLW  26
0228:  MOVWF  xCA
....................             break; 
....................     } 
....................      
....................     // Switch to 16bit mode 
....................     SYNC = 0; 
022A:  BCF    FAC.4
....................     BRGH = 1; 
022C:  BSF    FAC.2
....................     BRG16 = 1; 
022E:  BSF    FAA.3
....................     // Select 9-bit reception 
....................     //RX9 = 0; 
....................     // Disable uart address detecion on receive 
....................     //ADDEN = 0; 
....................     // Configure uart speed 
....................     SPBRG = divisor; 
0230:  MOVFF  CB,FB0
0234:  MOVFF  CA,FAF
....................      
....................     // Timer 1 is used as timeout generator 
....................     // The time is defined using UART_RX_TIMEOUT 
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
0238:  MOVLW  B5
023A:  MOVWF  FCD
....................      
....................     enable_interrupts(INT_RDA); 
023C:  BSF    F9D.5
023E:  GOTO   049C (RETURN)
.................... } 
....................  
.................... void parse_uart_data() 
.................... { 
....................     (*parse_next)(); 
*
0406:  CLRF   FEA
0408:  MOVLW  C2
040A:  MOVWF  FE9
040C:  RCALL  01CC
040E:  GOTO   04B6 (RETURN)
.................... } 
....................  
.................... void wait_for_start() 
.................... { 
....................     //* If there is no data available, return */ 
....................     if (!uart_bkbhit) 
*
0262:  MOVF   5B,W
0264:  SUBWF  5A,W
0266:  BNZ   026A
....................         return; 
0268:  BRA    0294
....................      
....................     /* If the data is start character, we update the state */ 
....................     if (uart_bgetc() == '#') 
026A:  RCALL  0242
026C:  MOVF   01,W
026E:  SUBLW  23
0270:  BNZ   0294
....................     { 
....................         /* Initialize data variables, just in case */ 
....................         data.dev_address = 0; 
0272:  CLRF   xBE
....................         data.ID = 0; 
0274:  CLRF   xBF
....................         data.data_length = 0; 
0276:  CLRF   xC0
....................         data.crc = 0; 
0278:  CLRF   xC1
....................         count = 0; 
027A:  CLRF   xC4
....................         parse_next = wait_for_adr; // Next we parse the [ID] field 
027C:  MOVLW  02
027E:  MOVWF  03
0280:  MOVLW  96
0282:  MOVWF  xC2
0284:  MOVFF  03,C3
....................          
....................         set_timer1(TIMER1_REFRESH); 
0288:  MOVLW  D8
028A:  MOVWF  FCF
028C:  MOVLW  F0
028E:  MOVWF  FCE
....................         clear_interrupt(int_timer1); 
0290:  BCF    F9E.0
....................         enable_interrupts(int_timer1); 
0292:  BSF    F9D.0
....................     } 
0294:  RETURN 0
.................... } 
....................  
.................... void wait_for_adr() 
.................... { 
....................     //* If there is no data available, return */ 
....................     if (!uart_bkbhit) 
0296:  MOVF   5B,W
0298:  SUBWF  5A,W
029A:  BNZ   029E
....................         return; 
029C:  BRA    02B8
....................      
....................     data.dev_address = uart_bgetc(); 
029E:  RCALL  0242
02A0:  MOVFF  01,BE
....................     set_timer1(TIMER1_REFRESH); 
02A4:  MOVLW  D8
02A6:  MOVWF  FCF
02A8:  MOVLW  F0
02AA:  MOVWF  FCE
....................     //enable_interrupts(int_timer1); 
....................     parse_next = parse_id; 
02AC:  MOVLW  02
02AE:  MOVWF  03
02B0:  MOVLW  BA
02B2:  MOVWF  xC2
02B4:  MOVFF  03,C3
02B8:  RETURN 0
....................      
.................... } 
.................... void parse_id() 
.................... { 
....................     //* If there is no data available, return */ 
....................     if (!uart_bkbhit) 
02BA:  MOVF   5B,W
02BC:  SUBWF  5A,W
02BE:  BNZ   02C2
....................         return; 
02C0:  BRA    02DC
....................      
....................     data.ID = uart_bgetc(); 
02C2:  RCALL  0242
02C4:  MOVFF  01,BF
....................     set_timer1(TIMER1_REFRESH); 
02C8:  MOVLW  D8
02CA:  MOVWF  FCF
02CC:  MOVLW  F0
02CE:  MOVWF  FCE
....................     parse_next = parse_length; 
02D0:  MOVLW  02
02D2:  MOVWF  03
02D4:  MOVLW  DE
02D6:  MOVWF  xC2
02D8:  MOVFF  03,C3
02DC:  RETURN 0
.................... } 
....................  
.................... void parse_length() 
.................... { 
....................     //* If there is no data available, return */ 
....................     if (!uart_bkbhit) 
02DE:  MOVF   5B,W
02E0:  SUBWF  5A,W
02E2:  BNZ   02E6
....................         return; 
02E4:  BRA    0300
....................      
....................     data.data_length = uart_bgetc(); 
02E6:  RCALL  0242
02E8:  MOVFF  01,C0
....................     set_timer1(TIMER1_REFRESH); 
02EC:  MOVLW  D8
02EE:  MOVWF  FCF
02F0:  MOVLW  F0
02F2:  MOVWF  FCE
....................     parse_next = parse_data; 
02F4:  MOVLW  03
02F6:  MOVWF  03
02F8:  MOVLW  02
02FA:  MOVWF  xC2
02FC:  MOVFF  03,C3
0300:  RETURN 0
.................... } 
....................  
.................... void parse_data() 
.................... { 
....................     //* If there is no data available, return */ 
....................     if (!uart_bkbhit) 
0302:  MOVF   5B,W
0304:  SUBWF  5A,W
0306:  BNZ   030A
....................         return; 
0308:  BRA    034A
....................     /* Add received byte to the data_length variable. 
....................        The bytes arrive in Big Endian order. */ 
....................     data.data_buffer[count] = uart_bgetc(); 
030A:  CLRF   03
030C:  MOVF   xC4,W
030E:  ADDLW  9E
0310:  MOVWF  01
0312:  MOVLW  00
0314:  ADDWFC 03,F
0316:  MOVFF  01,C8
031A:  MOVFF  03,C9
031E:  RCALL  0242
0320:  MOVFF  C9,FEA
0324:  MOVFF  C8,FE9
0328:  MOVFF  01,FEF
....................     count++; 
032C:  INCF   xC4,F
....................     set_timer1(TIMER1_REFRESH); 
032E:  MOVLW  D8
0330:  MOVWF  FCF
0332:  MOVLW  F0
0334:  MOVWF  FCE
....................     /* State transition rule */ 
....................     if (count == data.data_length) 
0336:  MOVF   xC0,W
0338:  SUBWF  xC4,W
033A:  BNZ   034A
....................     { 
....................         count = 0;  // Reset counter 
033C:  CLRF   xC4
....................         parse_next = parse_crc; 
033E:  MOVLW  03
0340:  MOVWF  03
0342:  MOVLW  88
0344:  MOVWF  xC2
0346:  MOVFF  03,C3
....................     } 
034A:  RETURN 0
.................... } 
....................  
.................... void parse_crc() 
.................... { 
....................     //* If there is no data available, return */ 
....................     if (!uart_bkbhit) 
*
0388:  MOVF   5B,W
038A:  SUBWF  5A,W
038C:  BNZ   0390
....................         return; 
038E:  BRA    03BE
....................      
....................     data.crc = uart_bgetc(); 
0390:  RCALL  0242
0392:  MOVFF  01,C1
....................     set_timer1(TIMER1_REFRESH); 
0396:  MOVLW  D8
0398:  MOVWF  FCF
039A:  MOVLW  F0
039C:  MOVWF  FCE
....................     // Check CRC 
....................     if (!crc_check()) 
039E:  BRA    034C
03A0:  MOVF   01,F
03A2:  BNZ   03B2
....................     { 
....................         parse_next = wait_for_start; 
03A4:  MOVLW  02
03A6:  MOVWF  03
03A8:  MOVLW  62
03AA:  MOVWF  xC2
03AC:  MOVFF  03,C3
....................         return; 
03B0:  BRA    03BE
....................     } 
....................     parse_next = parse_end; 
03B2:  MOVLW  03
03B4:  MOVWF  03
03B6:  MOVLW  C0
03B8:  MOVWF  xC2
03BA:  MOVFF  03,C3
03BE:  RETURN 0
.................... } 
....................  
.................... void parse_end() 
.................... { 
....................     //* If there is no data available, return */ 
....................     if (!uart_bkbhit) 
03C0:  MOVF   5B,W
03C2:  SUBWF  5A,W
03C4:  BNZ   03C8
....................         return; 
03C6:  BRA    0404
....................      
....................     disable_interrupts(int_timer1); 
03C8:  BCF    F9D.0
....................     timer1_isr_count = 0; 
03CA:  CLRF   xC5
....................     // If last byte isn't stop character, something goes wrong in transmission 
....................     // and package will be rejected 
....................     if (uart_bgetc() != '$') 
03CC:  RCALL  0242
03CE:  MOVF   01,W
03D0:  SUBLW  24
03D2:  BZ    03E2
....................     { 
....................         parse_next = wait_for_start; 
03D4:  MOVLW  02
03D6:  MOVWF  03
03D8:  MOVLW  62
03DA:  MOVWF  xC2
03DC:  MOVFF  03,C3
....................         return; 
03E0:  BRA    0404
....................     } 
....................     parse_next = wait_for_start; 
03E2:  MOVLW  02
03E4:  MOVWF  03
03E6:  MOVLW  62
03E8:  MOVWF  xC2
03EA:  MOVFF  03,C3
....................     // Handle data 
....................     printf(uart_bputc, "Message receive done.\r\n"); 
03EE:  MOVLW  DA
03F0:  MOVWF  FF6
03F2:  MOVLW  01
03F4:  MOVWF  FF7
03F6:  CLRF   19
03F8:  BTFSC  FF2.7
03FA:  BSF    19.7
03FC:  BCF    FF2.7
03FE:  RCALL  0178
0400:  BTFSC  19.7
0402:  BSF    FF2.7
0404:  RETURN 0
.................... } 
....................  
.................... short crc_check() 
*
034C:  CLRF   xC9
.................... { 
....................     int i; 
....................     int crc8 = 0; 
....................     crc8 = crc8 ^ data.dev_address ^ data.ID ^ data.data_length; 
034E:  MOVF   xC9,W
0350:  XORWF  xBE,W
0352:  XORWF  xBF,W
0354:  XORWF  xC0,W
0356:  MOVWF  xC9
....................     for(i=0; i<data.data_length; i++) 
0358:  CLRF   xC8
035A:  MOVF   xC0,W
035C:  SUBWF  xC8,W
035E:  BC    0376
....................         crc8 = crc8 ^ data.data_buffer[i]; 
0360:  CLRF   03
0362:  MOVF   xC8,W
0364:  ADDLW  9E
0366:  MOVWF  FE9
0368:  MOVLW  00
036A:  ADDWFC 03,W
036C:  MOVWF  FEA
036E:  MOVF   FEF,W
0370:  XORWF  xC9,F
0372:  INCF   xC8,F
0374:  BRA    035A
....................      
....................     return crc8 == data.crc; 
0376:  MOVF   xC1,W
0378:  SUBWF  xC9,W
037A:  BZ    0380
037C:  MOVLW  00
037E:  BRA    0382
0380:  MOVLW  01
0382:  MOVWF  01
0384:  GOTO   03A0 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void main() 
*
0412:  CLRF   FF8
0414:  BCF    FD0.7
0416:  BSF    07.7
0418:  BCF    F94.0
041A:  BCF    F8B.0
041C:  BSF    FAA.3
041E:  MOVLW  11
0420:  MOVWF  FAF
0422:  MOVLW  04
0424:  MOVWF  FB0
0426:  MOVLW  A6
0428:  MOVWF  FAC
042A:  MOVLW  90
042C:  MOVWF  FAB
042E:  MOVLW  02
0430:  MOVWF  03
0432:  MOVLW  62
0434:  MOVWF  xC2
0436:  MOVFF  03,C3
043A:  CLRF   xC4
043C:  CLRF   xC5
043E:  CLRF   xC7
0440:  CLRF   xC6
0442:  BCF    FB9.0
0444:  BCF    FC1.6
0446:  BCF    FC1.7
0448:  MOVLW  00
044A:  MOVWF  FB8
044C:  BRA    0454
044E:  DATA A8,40
0450:  DATA 1A,00
0452:  DATA 00,00
0454:  MOVLW  00
0456:  MOVWF  FF8
0458:  MOVLW  04
045A:  MOVWF  FF7
045C:  MOVLW  4E
045E:  MOVWF  FF6
0460:  TBLRD*+
0462:  MOVF   FF5,W
0464:  MOVWF  00
0466:  XORLW  00
0468:  BZ    0490
046A:  TBLRD*+
046C:  MOVF   FF5,W
046E:  MOVWF  01
0470:  BTFSC  FE8.7
0472:  BRA    047E
0474:  ANDLW  0F
0476:  MOVWF  FEA
0478:  TBLRD*+
047A:  MOVFF  FF5,FE9
047E:  BTFSC  01.6
0480:  TBLRD*+
0482:  BTFSS  01.6
0484:  TBLRD*+
0486:  MOVFF  FF5,FEE
048A:  DCFSNZ 00,F
048C:  BRA    0460
048E:  BRA    0482
0490:  CLRF   FF8
.................... { 
....................     uart_init(2, 120);  
0492:  MOVLW  02
0494:  MOVWF  xC8
0496:  MOVLW  78
0498:  MOVWF  xC9
049A:  BRA    0202
....................     enable_interrupts(GLOBAL); 
049C:  MOVLW  C0
049E:  IORWF  FF2,F
....................      
....................     printf(uart_bputc, "\r\n\Running...\r\n"); 
04A0:  MOVLW  F2
04A2:  MOVWF  FF6
04A4:  MOVLW  01
04A6:  MOVWF  FF7
04A8:  CLRF   19
04AA:  BTFSC  FF2.7
04AC:  BSF    19.7
04AE:  BCF    FF2.7
04B0:  RCALL  0178
04B2:  BTFSC  19.7
04B4:  BSF    FF2.7
....................      
....................     while (1) 
....................     { 
....................         //delay_ms(5000); 
....................         //printf("\r\nBuffered data => \r\n"); 
....................         while (uart_bkbhit) 
04B6:  MOVF   5B,W
04B8:  SUBWF  5A,W
04BA:  BZ    04C0
....................             parse_uart_data(); 
04BC:  BRA    0406
04BE:  BRA    04B6
04C0:  BRA    04B6
....................     } 
.................... } 
....................  
04C2:  BRA    04C2

Configuration Fuses:
   Word  1: 0600   H4 NOFCMEN NOIESO
   Word  2: 3E0D   NOPUT NOBROWNOUT BORV20 NOWDT WDT32768 NOWINEN
   Word  3: 9C3C   NOPWMPIN LPOL_HIGH HPOL_HIGH T1LOWPOWER FLTAD4 SSP_RC PWM4B5 EXCLKC3 MCLR
   Word  4: 0001   STVREN NOLVP DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
